"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = [{ "title": "Unit Testing ReactJS | Tape vs. Jest", "description": "After recently switching my unit tests from Tape to using Jest I decided to write a post on some of my experiences while teaching readers a lesson on testing!", "slug": "tape-jest-testing", "author": "Thomas Greco", "date": "2017-9-05 15:00 PDT", "tags": ["ReactJS", "Testing"], "body": "\n\n## Getting Acquainted with Jest\n### Intro\nLike any developer, my preference of tools has been built pretty much entirely on my past experiences. If i’m not using the tool and it’s known to be an aid to developers then there’s a good chance i’m uninformed on the topic. This was particularly true with Jest, which has become the most widely used library for testing ReactJS applications, so I thought it would be wise to explore the topic a little bit in a blog post. In this post, I want to share my feedback about recently using Jest while contributing to the next-static project.  \n\nI recently ended up pivoting from a dynamic web application to a static site for tgrecojs.com. next-static and the solution has worked A1 so I ended up contributing to the project. The first order of business was to write some tests for this project so I dove right in. Throughout 2017 I received a ton of experience writing unit tests for ReactJS apps but I always used tape so it was no shock that I initially gravitated to my normal dev environment for writing tests.\n\n### Reading the Unit Test\nA few minutes after getting my environment set up I had the boilerplate for my first `test.js` file all ready to go. \n\nBelow, we can see the code submitted in [initial pull request](https://github.com/infiniteluke/next-static/pull/9/commits/006dbe18a2b80f25f9b4d95c090e940da09f09f7).\n\n```javascript\n// imports….\n// set up for test scope\ntest('<Post />', nest => {\n  nest.test('given no props', assert => {\n    const msg = `should render a post`;\n\n    const props = makeProps();\n    const re = RegExp(props);\n\n    const el = <Post {...props} />;\n\n    const $ = dom.load(render(el));\n    const output = $('.post').html();\n    const actual = re.test(output);\n    const expected = true;\n\n    assert.same(actual, expected, msg);\n    assert.end();\n  });\n});\n```\n\nOnce ran, this log for this test would look like the image below.\n\n![tap](https://s26.postimg.org/7glcfzwjd/TAP-_OUTPUT.png)\n\nIsn’t that pretty? I’m a sucker for some good TAP which tape produces. Little did I know that I was taking it for granted but more on that in a moment. At this point, I finally had something that I could confidently push over to the next-static repo. About a day later, I received this remark from the project owner.\n\n![next static issue](https://s26.postimg.org/a0gza3k3d/Screen_Shot_2017-09-05_at_1.03.05_AM.png)\n\nBut of course! Why was I using this stone-age technology when I could just plug in Jest!? All kidding aside I wasn’t surprised by this. I know how crazy important of a tool Jest has become to so many developers and I was just excited to dive into the framework.\n\n### Becoming one with Jest\nI knew that migrated this super basic test wasn’t going to be hard. I just needed to know how my test was to be set up.\n\nI initially had the project's `test` script to fire off the [babel-cli](https://www.npmjs.com/package/babel-cli)  and run any tests that has been imported inside of an entry point file, which in my case was [`index.test.js`](https://github.com/infiniteluke/next-static/pull/9/commits/006dbe18a2b80f25f9b4d95c090e940da09f09f7#diff-275a6743b2ff7d68e3d76f3462691716). Because I was now relying on Jest, I could remove this file and I could also change the `test` script to `jest`. Once that was in place, Jest was pretty much ready to go. \n\nOne of Jest’s marquee behaviors is it’s ability to magically runs tests as long as they are either:\n* in *.test.js or *.spec.js\n* they are in a tests folder.\n\nAt the time of writing my test, I wasn’t even aware of this criteria however my code was inside [test.js](https://github.com/infiniteluke/next-static/blob/master/src/components/Post/test.js) file so everything worked out great. Additionally, I could completely eliminate that main index.test.js file as the `jest` command would navigate to the tests on its own. Once inside these tests, Jest will look for specific global variables that it provides users with for writing tests. In my case, I had to swap out `test` for Jest's `describe` function which will signify that a test suite has been created.\n\n> \"In your test files, Jest puts each of these methods and objects into the global environment. You don't have to require or import anything to use them.\"\n - [Jest Docs on Globals](https://facebook.github.io/jest/docs/en/api.html)\n\n\nThese globals are what allow Jest to magically run our tests without needing us to any code. I don’t want to be over critical of an extremely well known tool like Jest however I became very conscious of polluting my global scope throughout the last year. Yes, even in regards to testing. Over time, I became super comfortable with importing tape directly. It only took a write an import statement (I could add to a VS code snippet if I really needed to) and I feel comfort in knowing my test code is completely self-contained and free from outside bugs. Now, I don’t want to make it seem like i’m nitpicking here. This is merely my feedback on the library. That being said, I think that this no set-up configuration could allows testing to get off the ground as soon as possible.\n\n\nSure enough, I ran my tests and saw that Jest was picking up on my code. I didn’t know the .test or .spec criteria at this time but my tests already fell in line with the criteria necessary. I modified my code to fit Jest’s syntax, and my unit test looked like the following.\n\n```javascript\ndescribe('<Post /> with no args', () => {\nit('should render a post with default args', () => {\nconst props = makeProps();\nconst re = RegExp(props);\n\nconst el = <Component {...props} />;\n\nconst $ = loadComponent(el);\n\nconst output = $('.post').html();\nconst actual = re.test(output);\nconst expected = true;\n\nexpect(actual).toEqual(expected);\n    });\n});`\n```\n\nAs you can see, my test no longer has the `assert` call back that was used with Tape. Instead, we see Jest’s `expect` function to create test assertions. Specifically, we see `expect` asserting that the `actual` value is equal to the `expected` value using `toEqual`. As you can see, migrating this test really didn’t take much and it felt good know that I could have certainly migrated any test’s I’ve written to use Jest without any sort of conflict. Same concepts just different libraries. I love sinking my teeth into knew technologies (especially if I can undertand them from the jump) so it felt good to have my tests now passing with Jest. \n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/8QXkTFKrW5U\" frameborder=\"0\" allowfullscreen></iframe>\n\n### You had one job\nA day after pushing my newly committed Jest’ test to the next-static repo, I was informed that I failed to fully understand what was being asked of me. I produced a unit test but I really needed to create a snapshot test. Great! Now that I correctly identified the objective, I just needed to find out what exactly a snapshot test was.\n\n### Enter Snapshot Testing\nAs it’s name suggests, a snapshot test will take a `snapshot` of a component each time a test is run. If there is an existing snapshot, Jest will compare the two to make sure that nothing in our UI has changed unexpectedly. This is meant to provide developers with instant feedback of their UI. Whereas unit test assertions are meant to test a specific behavior, snapshot tests allow us to monitor trivial modifications in our UI. \n\nTo accomplish this, we use the `react-test-renderer` library’s `.toMatchSnapshot()` method. Once this is set up, Jest will compare the snapshot of our component to any previous snapshot’s and test their contents are the same. \n\n```javascript\ndescribe('Snapshot::<Post />s', () => {\nit('should render the contents of the component.', () => {\nconst props = makeProps();\nconst el = <Component {...props} />;\n\nconst tree = renderer.create(el).toJSON();\n\nexpect(tree).toMatchSnapshot();\n    });\n});\n```\n\nBelow is the exact snapshot Jest created for the `<Post/>` component. I’m not going to explain each line but you should be able to easily reason about what the UI should render. \n\n```javascript\n// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Snapshot::<Post />s should render the contents of the component. 1`] = `\n<article\n  className=\"post Post__Article-s1eculme-0 fQItYZ\"\n  itemScope={true}\n  itemType=\"http://schema.org/BlogPosting\";\n>\n  <header>\n    <a\n      href=\"/post/test-post\"\n      onClick={[Function]}\n    >\n      <h1\n        className=\"post--title\"\n        itemProp=\"headline\"\n      >\n        Hello\n      </h1>\n    </a>\n    <footer\n      className=\"post--info\"\n    >\n      <span>\n        <time\n          dateTime=\"7/22/2017\"\n          itemProp=\"datePublished\"\n        >\n          about 1 month ago\n        </time>\n      </span>\n      <span\n        itemProp=\"author\"\n      >\n        User\n      </span>\n    </footer>\n  </header>\n  <div\n    className=\"post--body\"\n    dangerouslySetInnerHTML={\n      Object {\n        \"__html\": \"<p>lorem ipsum is the name making tests is this game</p>\n      \",\n      }\n    }\n  />\n  <footer>\n    <small\n      className=\"post--tags\"\n    >\n      <span>\n        Filed under: \n      </span>\n      <span\n        className=\"post--tag\"\n        itemProp=\"keywords\"\n      >\n        <a\n          href=\"/tag/javascript\"\n          onClick={[Function]}\n        >\n          javascript\n        </a>\n        , \n      </span>\n      <span\n        className=\"post--tag\"\n        itemProp=\"keywords\"\n      >\n        <a\n          href=\"/tag/angular\"\n          onClick={[Function]}\n        >\n          angular\n        </a>\n        \n      </span>\n    </small>\n  </footer>\n</article>\n`;\n```\n\nAs you can see, Jest has created a readable representation of our UI. From this point forward, any future implementations of `<Post/>` will be tested against this snapshot. To get a better understanding of this, let’s see what happens when we remove the `<footer>` from our `Post` component and run our snapshot test. \n\n![jest snapshot ss](https://s26.postimg.org/o2ybbc03d/Screen_Shot_2017-09-04_at_5.01.48_PM.png)\n\nTaking a look at this image, we see that Jest is expecting the `<footer>` div and it can’t find it inside our component. As a result of this, we see the`-` sign thus signifying that the code block has been removed from the file.   If I was instructed to remove this footer, I would acknowledge this change and run `jest -u` to update my snapshot but I wasn’t. Instead, I was creating the initial snapshot for this component and therefore I didn’t have to worry about prior snapshots. The fact that I had created the starting point for futures tests was good enough.\n\n\n![jest update snapshot ss](https://s26.postimg.org/xdf0sm06v/Screen_Shot_2017-09-04_at_5.06.21_PM.png)\n\nAt this point I was further seeing seeing the benefits that Jest bring to a project but I haven’t been completely sold on it being the end all be all of testing solutions. It’s meant to run super quickly but I found that my tests actually ran a bit quicker with tape which would make sense due to how lightweight tape is. \n\nAdditionally, tape allows me to use TAP. Call me old-fashioned but TAP has been around since the 1980’s. That’s older than me and technologies that have lasted this long are usually etched in stone for good reason. I haven’t personally tried to integrate a custom TAP reporter with Jest but from what i’ve gathered it’s fairly difficult task. Is this the end of the world? No. Not at all but it’s worth noting. On the other hand, when the `—watch` flag is used, Jest offers a pretty cool interface that makes running specific tests a breeze. `—watch` keeps Jest running after creating snapshot tests and offer us the ability to update our previous snapshots by just pressing `u`.\n\n\n\n### Final Words\nThere’s no denying that Jest makes it easy to get begin testing code. In fact, easy is putting it lightly. As I just mentioned, it was so easy that I was initially a bit confused as to how this was supposed to work but the point is that it did indeed work. Aside from the globabl varables and not being able to easily print test results in TAP and the global variables, I have no qualms about the effectiveness of Jest. On the contrary, I am really excited to see what else Jest has to offer as I know that this isn't the last I will see of it!\n" }, { "title": "5 (of the many things) to love about Next.js", "description": "Next.js continues to be considered a “win” amongst a number of developers everywhere. (If you couldn't guess, I am one of them!) To help shine light on some of the reasons why I love the framework, I dediced to put together a series of posts on the topic. In this first one, I'm going to cut right to the chase and shed light on a few of the amazing things that Next.js makes possible.", "slug": "next-js-part1", "author": "Thomas Greco", "date": "2017-8-29 20:00 EST", "tags": ["ReactJS", "nextjs"], "body": "\n\n[Next.js](https://zeit.co/blog/next) continues to be considered a “win” amongst a number of developers everywhere. If you couldn't guess, I am one of them! To help shine light on some of the reasons why I love the framework, I dediced to put together a series of posts on the topic. In this first one, I'm going to cut right to the chase and shed light on a few of the amazing things that Next.js makes possible.\n\n\n### Ease of Use\n\nAnyone who has used the technology will tell you how easy it is to get started building a project with Next.js. You can have an app running as quickly as you’re computer can install the required packages... seriously.\n\nBelow is all that’s needed to create the shell for an app.\n\n```bash\nnpm init -y # creates package.json\nnpm install react react-dom next # self explanatory\nmkdir pages && touch pages/index.js\n```\n\nGranted that you’re package.json’s `script`'s object has been [modified correctly](https://github.com/zeit/next.js/#setup), you can paste the code below into the `pages/index.js`, run `npm run dev` and watch you’re application come to life.\n\n```javascript\nimport React from 'react';\n\nexport default ({title = 'How tight is this next.js thing?'}) => <h2>{title}</h2>;\n```\n<code>pages</code> acts as our router in Next.js. If we added the same code toa new file named `pages/about.js` and then visited `localhost:3000/about`, we'll see that our component is displayed and Next.js took care of the routing for us! Now let's continue on to some more cool stuff.\n\n\n### Automatic Code Splitting\n\nAny programmer in the now will tell you how important code splitting is to ensure an application’s performance is optimal. As it’s name suggests, [code splitting](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=3&cad=rja&uact=8&ved=0ahUKEwiMpYm24JHWAhXFSyYKHR-VAk4QFggyMAI&url=https%3A%2F%2Fwebpack.github.io%2Fdocs%2Fcode-splitting.html&usg=AFQjCNHoevmMDgzx9nVy7XMvPx5xusQ3Kg) allows us to *split* our application code up into a series of lightweight bundles. Instead of loading all of our JavaScript, our application will only load the bundle needed. Webpack is the tool most associated with this process. Instead of having to configure webpack to perform this, we can rely on Next.js! Let' get a better understanding of how this is accomplished so we can better understand what's going on. \n\nBelow shows an example of the `.next` directory created from running `next build`. \n\n![nextjs build directory](https://s3.postimg.org/p628izu1f/Screen_Shot_2017-08-23_at_2.52.45_AM.png)\n\nInside `.next` we see the `bundles` folder. When our `next build` runs, it uses webpack to generate bundles based on our app's `pages` directory. `pages` acts as a file system which allows Webpack easily target this directory and succeed in bundling our code without us having to do a thing. Additionally, application will load the `index.js` bundle when a visiter hits the `/` route. If a user then visits `/blog` route then the `index.js` bundle will be swapped in for the `blog.js` bundle.\n\n### Prefetching\n\nPrefetching picks off where code splitting leaves off. Next.js allows all of our optimized bundles of code to be lazily-loaded behind the scenes. \n\nTo harness the benefits of prefetching, all users need to do is add the `prefetch` attribute to their Link components.\n\n```javascript\n// Will NOT prefetch route\n<Link href=\"/blog\" />\n// Will have response cached and ready to go :)\n<Link prefetch href=\"/blog\" />\n```\n\nWhen next.js sees `prefetch`, it will provide a ServiceWorker for the corresponding route which will load all of the JavaScript behind the scenes. I, [along with other developers](https://github.com/zeit/next.js/issues/740), was initially under the impression that this magic `prefetch` attribute would wire up a service worker that would cache my applicaton's blog posts. After all, I linked to them with `prefetch`! It turns out that this is actually better that we must wire up our own service worker to perform this. It's also a tremendous example of how the tools Next.js provides users with are so crucial yet till pretty unonpinionated. Next.js wants nothing to do with how you handle your data. They just want to supply the tools needed for you to handle it in the best manner.\n\n### Server Side Rendering\nI still haven’t covered the fact that Next.js allows all of our application code to utilize server side rendering (SSR), thus providing the [benefits that come with this](https://medium.com/walmartlabs/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8). By employing SSR, we…\n\n* eliminate the need for the client to download code by having the HTML ready in the response. \n* can provide users with an initial render of the the application’s view while loading the code in the background.\n* deploy SEO friendly applications that are both Indexable and crawlable.\n* do countless more awesome things with JavaScript.\n\nAdditionally, Next.js makes it super easy to define custom routes on the server using a framework of your choice or, if you’d like, you can roll your own server. Like many JavaScript developers, I have a lot of experience using ExpressJS so I was able to apply this knowledge to create a custom backend with just a few lines of code. \n\nBy taking a look at the [projects repo](https://github.com/zeit/next.js/tree/v3-beta/examples), you will see a slew of examples with frameworks like Express, Koa, and Hapi, further showing how extendable Next.js truly is. Next.js simply provides all of these amazing benefits and let’s the developer pick and choose how they want to harnesss them. \n\n### HMR and Error Reporting\nThe effectiveness of [Hot-module replacement](https://webpack.github.io/docs/hot-module-replacement.html) (HMR) has made it a must-have for the development process. Instead of reloading an entire application when code is changed, HMR will only recreate modules that have been altered. Webpack’s homepage describes the practice as “Livereload for every module” so as you can image, this allows next.js to come equipped with a high-powered development process but it doesn’t stop there. Users will quickly learn about the amazing error messages that Next.js immediately renders to the browser whenever code is in correct. \n\nYes, you’ve heard that correct. I said “amazing error messages”. Surely I must be crazy. Well, take a look for yourself. I’ve recorded a quick clip of this in action. \n\n<div style=\"display: flex; justify-content: center\">\n<iframe src=\"https://giphy.com/embed/3ov9jYfehcX86yv4xa\" width=\"480\" height=\"281\" frameBorder=\"0\"allowFullScreen></iframe>\n</div>\n\nAt first we see the application being rendered correctly in the browser. To demonstrate Next.js’ ability then see an error as a result of me removing the `>` symbol from my JSX. No matter how small, these errors can cause serious headaches due to all sorts of nonsense so I thought this provided a good example of Next.js instantly picking up the error and it doesn’t stop pinpoints the file and even the line on which this error is occurring thus making tracking down bugs a breeze. Every developer knows the struggle of spending more time than they’d be willing to admit on finding a bug, only to find out that the issue was embarrassingly trivial. Next.js eliminates this problem and allows developers to work with great efficiency. \n\n### Final thoughts\nHopefully by now you’re beginning to realize how powerful of a framework Zeit has created with Next.js. In my next post, i'm going to dive deeper into Next.js and in particular, my experiences working it. In the meantime, I highly recommend you checking out yet another home-run that Zeit has released to the people! \n\n##### Additional Resources\n* [Next.js Repo](https://github.com/zeit/next.js)\n* [Learn Next.js -- Awesome for beginners!!!](learnnextjs.com)\n* [Zeit Blog - Next.js 3](https://zeit.co/blog/next3)\n* [Zeit Slack](https://zeit.chat/)\n* [awesome-nextjs](https://github.com/unicodeveloper/awesome-nextjs)\n" }, { "title": "The Benefits of Using Functional Stateless Components in ReactJS", "description": "This article takes a look at Functional Stateless Components which React released in v0.14. Since then, they've made a huge impact in the community by providing users with a cleaner syntax that allows for us to write more declarative code. To show why this is so helpful, this article will take a look at stateless components and finish up with some unit tests.", "slug": "pure-components", "author": "Thomas Greco", "date": "2017-8-22 15:00 PDT", "tags": ["ReactJS", "Testing"], "body": "\n\n### Understanding Outcomes with Pure Components\nUse of Stateless Functional Components (a.k.a. “pure” or “dumb” components) in ReactJS continues to grow since first being released in React 0.14, and for good reason. By relying on pure components, developers end up writing reusable code thats extremely easy to test, thus leading to better application architecture. Why? A functional stateless component is merely a factory function used to create a react component. Personally, I like the term “pure component” because its indicative of what the code really is — a pure function sprinkled with some JSX.\n\n> \"A pure function is a function which:\nGiven the same input, will always return the same output.\nProduces no side effects.\nRelies on no external mutable state.\" </br>\n> Eric Elliott, Master the JavaScript interview: [What is a Pure Function](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976)\n\nEquipped with the right amount of tests, the use of pure functions can help bring peace of mind to developers by ensuring that any scenario that has been tested will not have an unintended result in the application. As you can imagine, this can go along way when building large scale applications. It should also come as no surprise to know that pure functions are the heart of Redux which relies on JavaScript’s [`reduce`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=a) function. \n\nIn an upcoming post, i’ll go into further detail on how reduce works. For now, I want to continue on with the idea of writing “bullet-proof” React components using pure functions. To best illustrate this, i’m going to show some code that shows a react child component.\n\n```javascript\n// Post.js\nconst Post = ({ title, content }) =>\n<div className=\"post\">\n<h2>{title}</h2>\n<p>{content}</p>\n</div>;\n```\n\nThe clean nature of these components make it extremely easy to reason about the code. In this case, we see the that `Post` is just a function that takes title and content props and then uses these props to produce an element. You may often see `props` being passed in as a parameter but i’ve utilized ES6 [destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment). By doing so, my we’re able to pull specific values out of the `props` object and access `props.title` and `props.content` without using [dot notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors).\n\nPersonally, I think that this is awesome as it removes any mystery about the `props` being passed into a component. In programming, mystery is never good a thing so this allows us to read code than others can more easily reason about, especially as components become more large!\n\n### Why this is important\nAlthough this component may not look like much, it could very well play an integral part of an application. For instance, let's imagine `<Post/>` renders articles in for a website that has over a million daily users. If that's the case, then we will likely rather these smaller, cohesive blocks of code as they allow us to easily hammer out every last detail! You’ll also find that pure components make modifications a breeze and also result in writing code that can be easily ported into other projects. In addition to these benefits, pure components also make it extremely easy to test them with any crazy props that you wish. Like a pure function, pure components will always map the same input to the same output therefore **If we can think of the scenario, we can test how our component will react**.\n\n\n#### Diving into Unit Tests\nAs we just saw, the code for functional components provide us awesome intel on with everything we need to know in order to write effective tests. To best illustrate this, i’m going to take you through the code block below which is a unit test of the `<Post />` component.   \n\n```javascript\n// Post.test.js\nimport test from 'tape';\nimport dom from 'cheerio';\nimport Post from './Post';\nimport { renderToStaticMarkup } from 'react-dom';\n\ntest('<Post /> ', assert => {\nconst msg = 'should render a post with a title and content';\n// define preexisiting conditions\nconst props = {\ntitle: 'I am the title',\ncontent: 'I am the content!!!!!! Woooooooo!'\n};\nconst checkProps = RegExp(props);\n\nconst el = <Post {props} />\nconst $ = dom.load(render(el));\nconst output = $('post').html();\n\nconst actual = checkProps.test(output);\nconst expected = true;\n\nassert.same(actual, expected, same);\nassert.end()\n})\n```\n\nDon’t worry if the code above is a bit confusing to you. It will all make sense soon. \n\n\n### Step 1 - Set up pre-existing conditions\nIn this instance, we know that `<Post />` takes a `title` and a `content` prop so we can test this by simply passing in these values to a `props` variable. Once we’ve assigned the props we want to test, we can use JavaScript's `Regex` function to create another variable, `checkProps`, that will make sure the component being tested contains the props it is being given. \n\n```javascript\n// post.test.js\nconst props = {\ntitle: 'I am the title',\ncontent: 'I am the content!!!!!! Woooooooo!'\n};\nconst checkProps = RegExp(props);\n```\n\n### Step 2 - Render the HTML from `<div class=\"post\">`\nFollowing this, we then see the use of cheerio to render our component. Cheerio allows us to traverse and manipulate the DOM using its API. Additionally, Cheerio is lighting fast and as a result of that, it’s at the heart of popular libraries like [enzyme](https://github.com/airbnb/enzyme/blob/master/docs/api/render.md).\n\nTaking a look into our code, we can use cheerio's `.load` method to render our react element. From there, we simply pass in the selector of the contents which we want to check. In our case, it's the `.post` class Following our selector, we then see cheerio’s `.html()` method which will render the content from our selector and allow us to check for our component’s props.\n\n```javascript\n// Set up cheerio\nconst el = <Post {...props} />\nconst $ = dom.load(render(el));\nconst output = $(‘.post').html();\n```\n\n#### Step 3 - Test the props\nThe last thing we need to do is check the props of our `output` variabe. To do this, we have an `actual` value which will check to see if our component passes our `checkProps` test. If it does, that means the `actual` value will return `true` and give us a passing test!\n\n```javascript\nconst actual = checkProps.test(output);\nconst expected = true;\n// asserts that actual and expected are equal\nassert.same(actual, expected, msg);\n// ends assertion test\nassert.end();\n```\n\n#### Step 4 - Celebrate (Final Words)\nAwesome! You’ve made it to the end. Hopefully by now you’ve got a good understanding of how functional stateless components work in React. Personally, I can’t get enough of them and I hardly every try to use classes in my code. Why use `this` if you don’t need to? :)\n\n\n\n\n\n\n" }];